#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Хренов Г.Н.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Задача понимания естевственного языка является одной основных и наиболее естественных задач ИИ, поскольку  вполне естественно ожидать, от интелектуальной системы способности понимать естественный язык и общаться с пользователем на привычном ему уровне. Естественный язык – сложная система с неочевидной и гибкой структурой. Любой анализ естественного языка сводиться к нескольким этапам: предварительный анализ (поиск границ слов и предложений), морфологический анализ (установление словарных форм слов и приписывание им морфологических признаков), синтаксический анализ (зависимости между словами), семантический анализ (смысл предложения или отдельных слов).
 Prolog оказывается удобным языком для решения таких задач, потому что в нем есть понятие перебора с возвратом. Мы можем пытаться анализировать язык, и в случае противоречия сделать откат назад и искать другие возможные варианты.

## Задание

Реализовать преобразователь активных и пассивных форм типа: [’Саша’, ’и’, ’Лена’, ’любят’, ‘шоколад’]  и [’шоколад’, ’любим’, ’Сашей’, ’и’, ’Петей’]  в глубинные структуры типа и сравнить полученные глубинные структуры

Запрос: ?- compare([’Саша’, ’и’, ’Лена’, ’любят’, ‘шоколад’] , [’шоколад’, ’любим’, ’Сашей’, ’и’, ’Леной’], Ph1,Ph2, Y). Результат: Ph1=likes([agent(’Саша’), agent(’Лена’)], object(’шоколад’)), Ph2=likes([agent(’Саша’), agent(’Лена’)], object(’шоколад’)), Y=yes. 

## Принцип решения

Всем нашим предложениям будет соответствовать одна фреймовая структура:

	likes(agent(), object()).

Для обозначения свойств нам понадобится структурный терм f\2, содержащий информацию о числе и залоге (ed/mn, act,pass)

Основной предикат sentence обрабатывает случаи активного и пассивного залога, меняя субъект и объект в случае необходимости

	sentence(likes(agent(S),object(O))) -->
		agent_clause(S,F), verb_clause(_,F), {F=f(_,act)}, object_clause(O,_).
	sentence(likes(agent(S), object(O))) -->
		object_clause(O,_), verb_clause(_,F), {F=f(_,pass)}, agent_clause(S,F).

	sentence(S,R) :- sentence(R,S,[]). 


определяем  группу agent_clause:

	agent_clause(X,F) --> agent(X,F).
	agent_clause([A,'и',B], f(mn,_)) --> agent(A,_), ['и'], agent(B,_).

При перечислении объектов через 'и' объединяем их в один и присваиваем свойство множественного числа

Определяем verb_clause:

	verb_clause(action(A), f(N,act)) --> verb(A,f(N, act)).
	verb_clause(action(A), f(N,pass)) --> verb(A,f(N, pass)).

Далее идут словари:

	agent(S,f(ed,act)) --> {member(S, ['Саша', 'Петя', 'Лена'])}, [S].
	agent(S,f(ed,pass)) --> {member(n(S,N), [n('Саша','Сашей'), n('Петя','Петей'), n('Лена','Леной')])}, [N].
	object(S,f(ed,_)) --> {member(S, ['шоколад'])}, [S].

Имена в пассивном залоге я приводил к активному ради одинообразной фрэймовой структуры, которая получится на выходе. Объект реализован так намеренно с целью возможности пополнения словаря в будущем(хотя сейчас там 1 елемент). Фигурные скобки указывают, что в нотации dcg не нужно передовать 2 дополнительных аргумента

Далее идут предикаты сравнения по заданию:

	compare(A,B,Ph1,Ph2,Z) :- 
		sentence(A,Ph1),
		sentence(B,Ph2),
		synonim(A,B,Z).

	synonim(A,B,Z) :- sentence(A,F), sentence(B,F), Z = 'yes'.
	synonim(A,B,Z) :- sentence(A,D), sentence(B,F), D\=F, Z = 'no'.


## Результаты

?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'] , ['шоколад', 'любим', 'Сашей', 'и', 'Леной'],X,Y,Z).
X = Y, Y = likes(agent(['Саша', и, 'Лена']), object(шоколад)),
Z = yes .

?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'] , ['шоколад', 'любим', 'Сашей', 'и', 'Петей'],X,Y,Z).
X = likes(agent(['Саша', и, 'Лена']), object(шоколад)),
Y = likes(agent(['Саша', и, 'Петя']), object(шоколад)),
Z = no .

?- compare(['Лена', 'любит', 'шоколад'] , ['шоколад', 'любим', 'Леной'],X,Y,Z).
X = Y, Y = likes(agent('Лена'), object(шоколад)),
Z = yes .



## Выводы

Для анализа естественного языка prolog - наиболее подходящий вариант, поскольку в нем предусмотрен спциальный синтаксис, позволяющий просто интерпретировать предложения грамматики. В своей работе я добился извлечения глубинного смысла программой, что является необходимой составляющей анализа естественного языка. Однако задача понимания естественного языка до сих пор полностью не решена, хотя уже есть значительные продвижения в этой области. 



