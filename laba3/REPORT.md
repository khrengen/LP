#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Хренов Г. Н.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Задачи, которые имеют в себе набор ситуаций(состояний), и от каждого состояния можно с помощью каких-то действий перейти в другое состояние обычно решаются методом поиска в пространстве состояний. Такие задачи сводятся к задаче поиска в графе. Чтобы решить задачу, применяется один из видов поиска (поиск в глубину, поиск в ширину, поиск с итеративным погружением и т.д.).

Обычно граф задается матрицей смежности. Пролог удобен тем, что граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Такое задание является более гибким, так как дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать более сложные и большие графы, для которых матричное представление не всегда возможно.


## Задание

5.Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.

## Принцип решения

Для решения я использовал 3 метода: поиск в глубину(depth), ширину(width) и итеративным погружением(iter). Рассмотрим общие моменты решения.

Обозначим правила для перемещения шаров:

	move(A,B):-
	    append(H,[w,space|T],A),
	    append(H,[space,w|T],B).
	move(A,B):-
	    append(H,[space,b|T],A),
	    append(H,[b,space|T],B).
	move(A,B):-
	    append(H,[w,b,space|T],A),
	    append(H,[space,b,w|T],B).
	move(A,B):-
    	    append(H,[space,w,b|T],A),
 	    append(H,[b,w,space|T],B).

Чтобы черные и белые шары поменялись местами, нужно перемещать белые, у которых окно справа, черные, у которых окно слева. А также белые могут перепрыгивать через чёрные в окно справа и аналочично чёрные. Стоит заметить, что если решений будет несколько - они будут симметричны.



Продлеваем путь на 1, находим какой шаг мы можем сделать, и, чтобы программа не зациклиласть, нужно проверить, чтобы этот шаг не привел к состоянию, в котором мы уже были:

	prolong([X|Tail],[New,X|Tail]):-
    		move(X,New),
    		not(member(New,[X|Tail])).


Путь хранится в обратном порядке. Запишем наоборот:

	result([_]):-!.
	result([A,B|Tail]):-
    		result([B|Tail]),
    		nl,write(B),write(' -> '),write(A).



## Результаты


?- [solution].
true.

	?- search_depth([w,w,w,space,b,b,b],[b,b,b,space,w,w,w]).

	[w,w,w,space,b,b,b] -> [w,w,space,w,b,b,b]
	[w,w,space,w,b,b,b] -> [w,w,b,w,space,b,b]
	[w,w,b,w,space,b,b] -> [w,w,b,w,b,space,b]
	[w,w,b,w,b,space,b] -> [w,w,b,space,b,w,b]
	[w,w,b,space,b,w,b] -> [w,space,b,w,b,w,b]
	[w,space,b,w,b,w,b] -> [space,w,b,w,b,w,b]
	[space,w,b,w,b,w,b] -> [b,w,space,w,b,w,b]
	[b,w,space,w,b,w,b] -> [b,w,b,w,space,w,b]
	[b,w,b,w,space,w,b] -> [b,w,b,w,b,w,space]
	[b,w,b,w,b,w,space] -> [b,w,b,w,b,space,w]
	[b,w,b,w,b,space,w] -> [b,w,b,space,b,w,w]
	[b,w,b,space,b,w,w] -> [b,space,b,w,b,w,w]
	[b,space,b,w,b,w,w] -> [b,b,space,w,b,w,w]
	[b,b,space,w,b,w,w] -> [b,b,b,w,space,w,w]
	[b,b,b,w,space,w,w] -> [b,b,b,space,w,w,w]

	Time: 0.002500772476196289

	true.


	?- search_width([w,w,w,space,b,b,b],[b,b,b,space,w,w,w]).

	[w,w,w,space,b,b,b] -> [w,w,space,w,b,b,b]
	[w,w,space,w,b,b,b] -> [w,w,b,w,space,b,b]
	[w,w,b,w,space,b,b] -> [w,w,b,w,b,space,b]
	[w,w,b,w,b,space,b] -> [w,w,b,space,b,w,b]
	[w,w,b,space,b,w,b] -> [w,space,b,w,b,w,b]
	[w,space,b,w,b,w,b] -> [space,w,b,w,b,w,b]
	[space,w,b,w,b,w,b] -> [b,w,space,w,b,w,b]
	[b,w,space,w,b,w,b] -> [b,w,b,w,space,w,b]
	[b,w,b,w,space,w,b] -> [b,w,b,w,b,w,space]
	[b,w,b,w,b,w,space] -> [b,w,b,w,b,space,w]
	[b,w,b,w,b,space,w] -> [b,w,b,space,b,w,w]
	[b,w,b,space,b,w,w] -> [b,space,b,w,b,w,w]
	[b,space,b,w,b,w,w] -> [b,b,space,w,b,w,w]
	[b,b,space,w,b,w,w] -> [b,b,b,w,space,w,w]
	[b,b,b,w,space,w,w] -> [b,b,b,space,w,w,w]
	
	Time: 0.006236553192138672

	true.

	?- search_iter([w,w,w,space,b,b,b],[b,b,b,space,w,w,w]).

	[w,w,w,space,b,b,b] -> [w,w,space,w,b,b,b]
	[w,w,space,w,b,b,b] -> [w,w,b,w,space,b,b]
	[w,w,b,w,space,b,b] -> [w,w,b,w,b,space,b]
	[w,w,b,w,b,space,b] -> [w,w,b,space,b,w,b]
	[w,w,b,space,b,w,b] -> [w,space,b,w,b,w,b]
	[w,space,b,w,b,w,b] -> [space,w,b,w,b,w,b]
	[space,w,b,w,b,w,b] -> [b,w,space,w,b,w,b]
	[b,w,space,w,b,w,b] -> [b,w,b,w,space,w,b]
	[b,w,b,w,space,w,b] -> [b,w,b,w,b,w,space]
	[b,w,b,w,b,w,space] -> [b,w,b,w,b,space,w]
	[b,w,b,w,b,space,w] -> [b,w,b,space,b,w,w]
	[b,w,b,space,b,w,w] -> [b,space,b,w,b,w,w]
	[b,space,b,w,b,w,w] -> [b,b,space,w,b,w,w]
	[b,b,space,w,b,w,w] -> [b,b,b,w,space,w,w]
	[b,b,b,w,space,w,w] -> [b,b,b,space,w,w,w]

	Time: 0.0154571533203125

	true.



## Выводы

Лучше всех себя показал поиск в глубину - он справился быстрее всех за наименьшее число шагов. Этот поиск хорошо подходит для простых задач с малым количестом решений(в данном случае два симметричных решения).

Сравним алгоритмы. Поиск в глубину всегда идёт по первой ветви дерева до самой глубокой вершины и возвращается только при тупике или поиске других решений. Поиск в ширину же сначала обходит все пути длины 1, потом 2 и т.д.. В общем случае поиск в глубину требует сравнительно небольшой объём памяти, но в случае бесконечного дерева он может легко зациклиться и не найти решений. Поиск в ширину, наоборот, подходит для бесконечных деревьев, однако требует большего объема памяти. А вот алгоритм  поиска с итерационным заглублением сочетает в себе лучшие свойства двух предыдущих алгоритмов. Он не уступает по памяти поиску в глубину и не уступает по сложности поиску в ширину. Плата за это - небольшая просадка в производительности.

В целом, необходимо выбирать алгоритм в зависимости от ситуации, задачи, поскольку каждый алгоритм имеет свои преимущества и недостатки. А вот метод поиска в пространстве состояний оказался очень удобным, поскольку часто достаточно только поменять условия перехода состояний для решения другой задачи.




